{"componentChunkName":"component---src-templates-tutorial-index-tsx","path":"/tutorial/making-a-url-shortener/python","result":{"pageContext":{"author":["Ryan Yang","https://ryqn.dev"],"link":["tutorial","making-a-url-shortener","python"],"title":"Making a URL shortener in Python","summary":"This is the practical tutorial after the designing-a-url-shortener article in which we implement the design specified in Python using Flask.","tags":["web developement","API","backend","server","Python","Flask","intermediate"],"date":{"updated":"Tue, 14 Dec 2021 18:34:32 GMT","uploaded":"Tue, 14 Dec 2021 18:34:32 GMT"},"content":"# Making a URL shortener in Python\n\n*The finished code can be found [here](https://github.com/ryqndev/learn-ryqn-dev/tree/content-update/src/content/making-a-url-shortener-in-python/docs). To run it, you need to [setup Flask](https://learn.ryqn.dev/starting-out-with-flask#installation-and-setup). Once that's done, you can type `flask run` in your terminal to start the webserver*\n\n```table-of-contents\n\n* [Intro](#intro)\n* [Background info](#background-info)\n* [Picking our tools](#picking-our-tools)\n* [Installation and Setup](#installation-and-setup)\n* [Ready to start coding](#ready-to-start-coding)\n* [Writing the business logic](#writing-the-business-logic)\n    1. [Generating a short alias](#generating-a-short-alias)\n    2. [Get link from alias](#get-link-from-alias)\n    3. [Finishing up business logic](#finishing-up-business-logic)\n* [Understanding servers and web requests](#understanding-servers-and-web-requests)\n* [Writing the Flask code](#attaching-flask)\n    1. [Creating a web interface](#creating-a-web-interface)\n    1. [Redirecting](#redirecting)\n* [Final Result](#final-result)\n```\n\n## Intro \nThis tutorial assumes basic knowledge of Python3 (variables, functions, if-statements, dictionaries, import python modules).\n\nYou may have heard of services like [bit.ly](https://bit.ly) called URL shorteners whose job is to take a long link, and generate a shorter alias for it. \n\nHere, we will **write a URL shortener service in Python**. This article is meant for students who have dabbled with Python and are exploring ways to apply that knowledge to real-world applications. We'll be touching on setting up a webserver using Flask, serving webpages, understanding http codes, and some basic software design fundamentals. \n\nIdeally, you'll be able to see the process a developer goes through when writing software and learn enough from the system so you have *some* direction when you work on your own project!\n\n## Background info\nIf you want to dive straight into code, you can go straight to [Installation and Setup](#installation-and-setup). Otherwise, I would recommend you read an [in-depth explanation of the design of our system](https://learn.ryqn.dev/article/designing-a-url-shortener) first.\n\nWe are essentially developing this:\n![Demo of basic functionality of app](./assets/demo.gif)\n\nThis is what our code will be doing in the back:\n![Time sequence diagram](./assets/redirection-diagram.png)\nExcept our \"database\" will just be a dictionary variable in memory.\n### Picking our tools\nIn our design doc, we realized we needed a web application server. In Python, there are 2 main web application server libraries:[Flask](https://flask.palletsprojects.com/en/2.0.x/) and [Django](https://www.djangoproject.com/). \n\n*We will be using Flask due to its simplicity but you may want to look at a more in-depth breakdown between the two tools when you're doing professional development.*\n\n## Installation and Setup\nWe need to first install Python3 and  Flask, and setup our boilerplate code. Go ahead and hop [here](https://learn.ryqn.dev/article/starting-out-with-flask#write-a-flask-program-in-5-lines-of-code) first and follow these instructions until the `Where do we go from here?` section.\n\n## Ready to start coding\nAfter following the steps from the link above, you should end up with this basic structure:\n```file\n└── url-shortener\n            └── app.py\n```\n\n```python app.py\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n\treturn \"Hello World!\"\n\n```\n\nand when you run the command `flask run` in the terminal, you get this:\n```shell terminal\n~$ flask run\n\n* Environment: production\nWARNING: This is a development server. Do not use it in a production deployment.\nUse a production WSGI server instead.\n* Debug mode: off\n* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n```\n\nand when you open up [http://127.0.0.1:5000/](http://127.0.0.1:5000/) in the browser (any browser of your choice), you should see something like this:\n\n![result of opening up localhost:5000 in the browser](./assets/setup-result.png)\n\nIf you've made it this far, then that means you've set up Python and Flask correctly! The code that we just ran is pretty much the most barebones Flask application you can have. \n\nNotice that we only wrote 5 lines of code but when we ran it, our code spun up an entire webserver that immediately started listening for requests on the \"internet\" and responded to a request when we accessed [http://127.0.0.1:5000/](http://127.0.0.1:5000/) in the browser. If you knew what you were doing, this setup takes less than a minute. This is why we (and companies like Lyft and Netflix) reach for a library like Flask when we need to run a webserver.\n\n> One thing to note, companies like Lyft and Netflix likely *aren't* using Flask as a webserver for their main product, but rather for their internal tools. This is because Flask is valued for its simplicity and ability to prototype quickly. This makes Flask the tool of choice for educational tutorials (like this one), hackathons, and internal tooling. If you wanted a powerful and robust webserver expected to serve thousands of different webpages and millions of requests, you may want to reach for Django instead - but you should look at a more in-depth comparison between the tools first.\n\n## Writing the business logic\n\nWe're going to set the web server code aside for a quick second and work on the `business logic`. If you're not familiar with that term, **business logic simply means the core set of code that solves the main problem our app tackles**. (i.e. core algorithms)\n\nGoing back to the design document, our app is a URL shortener, but all of the setup we did with Flask actually has nothing to do with shortening URLs. In other words, despite being a vital part of our app (by being a medium for users to access our product and redirects short links), **our Flask code doesn't actually do any link shortening**. This is why our Flask code we wrote just now isn't considered \"business logic\" and should be **separate** from it. \n\nWe *could* write all of our code in one file - it would be okay since our codebase is going to be fairly small - but we should try to follow some good programming practices and splitting different pieces of logic into different files is vital to any codebase.\n\nWith that in mind, let's go ahead and create a new file in the same folder called `business_logic.py` and here we'll first list out all of the functions we expect to have.\n\n```file\n└── url-shortener\n            ├── app.py\n            └── business_logic.py\n\n```\n\n```python business_logic.py\n# We need a python dictionary variable that will store our mapping of \n# short_urls to long_urls\nlink_mappings = {\n    # Here's an example of a mapping\n    # 'https://short.com/d63hs': http://learn.ryqn.dev/making-a-url-shortener-in-python#writing-the-business-logic\n}\n\ndef create_short_link(long_link):\n    \"\"\"Should receive a link in the form of a string (ex. \n    https://short.com/...) and return a short alias that will redirect to \n    the original long_link parameter.\n    \"\"\"\n    pass\n\ndef get_long_link(short_link_id):\n    \"\"\"Look at dictionary of link_mappings and return the corresponding \n    long_link.\n    \"\"\"\n    pass\n\n```\n\n### Generating a short alias\n\nGenerating a short alias has 3 parts to it: Generating an unused random string (we can call this a hash), saving the `<hash, long_link>` pair, and returning the full aliased url. It would look something like this:\n\n```python business_logic.py\nimport random\n\nlink_mappings = {}\n\ndef create_short_link(server_url, long_link):\n    \"\"\"Generates and returns an alias for the given link\n\n    Parameters:\n        server_url [string]: Base URL of the server\n            Ex.: https://short.com/ (if example aliased link was https://short.com/d63hs)\n\n        long_link [string]: Original link that the alias should redirect to.\n            Ex.: http://learn.ryqn.dev/making-a-url-shortener-in-python#writing-the-business-logic\n\n    Returns:\n        [string]: full aliased url.\n            Ex.: https://short.com/d63hs\n    \"\"\"\n    LENGTH_OF_ALIAS_ID = 6\n    unused_hash = generate_random_string(LENGTH_OF_ALIAS_ID);\n\n    link_mappings[unused_hash] = long_link\n\n    return server_url + unused_hash\n\ndef generate_random_string(length_of_string):\n    \"\"\"Generates a valid random Base62 string of given length\n\n    Parameters:\n        length_of_string [int]: length of generated Base62 string\n            Ex.: 6\n\n    Returns:\n        [string]: random Base62 string\n            Ex.: d63hs\n    \"\"\"\n    ALPHANUMERIC_CHARACTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n\n    while True: # loops until it generates unused id. Not expected to iterate in majority cases.\n\n        # Generates list of characters randomly picked from ALPHANUMERIC_CHARACTERS string\n        # and then joins them together into a string.\n        valid_random_alphanumeric = ''.join(random.choice(\n            ALPHANUMERIC_CHARACTERS) for _ in range(length_of_string))\n\n        # Checks validity of generated id. Breaks from loop if valid, otherwise generate again\n        if valid_random_alphanumeric not in link_mappings:\n            return valid_random_alphanumeric\n\n# ...\n```\n\nNotice that in our `link_mappings`, we are storing the hash, rather than the entire url. This is because we know that every short url will be prepended with our server url - in this example it's https://short.com/. (don't actually go on this site, it's a fake domain i made up) \n\nBy not storing the whole link, not only do we save space in memory, we also solve another problem which is comparing URLS. https://short.com/d63hs, https://short.com/d63hs/, and http://short.com/d63hs are all \"technically\" the same URL but have different string values. However, we do know that they all have the same route: [d63hs] which is much easier to compare.\n\n### Get link from alias\n\nGetting the link is actually pretty simple, thankfully. Since we have a dictionary mapping of short alias id's to their original links, we just need to get the corresponding value of a key, like so:\n\n```python Access dictionary value in Python with key\nlong_link = link_mappings.get(short_link)\n\n# You may be more familiar with this way:\nlong_link = link_mappings[short_link]\n# but this second way throws a KeyError when the key doesn't exist, \n# whereas .get() will return None. It's better to check for None, \n# rather than catch the error because we expect this to happen \n# frequently\n\n```\n\nOur `get_long_link` function should end up looking like this:\n\n```python business_logic.py\n# ...\n\ndef get_long_link(short_link_id):\n    \"\"\"Finds and returns original link from alias\n\n    Parameters:\n        short_link_id [string]: random string of characters denoting alias. \n            Ex.: d63hs (if aliased link was https://short.com/d63hs)\n\n    Returns:\n        [string|None]: full original link as string or NoneType if link wasn't found. \n            Ex.: http://learn.ryqn.dev/making-a-url-shortener-in-python#writing-the-business-logic\n    \"\"\"\n    return link_mappings.get(short_link_id)\n\n```\n\n### Finishing up business logic\n\nWe can test our `business_logic.py` by adding this snippet at the end of our file:\n```python business_logic.py\n# ...\n\nif __name__ == \"__main__\":\n    long_link = \"http://localhost:3000/making-a-url-shortener-in-python#intro\"\n    short_link = create_short_link(\"https://short.com/\", long_link)\n    print(\"Converted:\", long_link, \"->\", short_link)\n    \n    print(\"Current state of link_mappings: \", link_mappings)\n\n```\n\nwhich simply says if we run this file by itself, execute those commands. Otherwise (like when we import it as a module for our Flask application), don't.\n\nAfter running the file by itself in the terminal, we get this:\n```bash \n~$ python business_logic.py\n\nConverted: http://localhost:3000/making-a-url-shortener-in-python#intro -> https://short.com/x1GZrT\nCurrent state of link_mappings:  {'x1GZrT': 'http://localhost:3000/making-a-url-shortener-in-python#intro'}\n```\n## Understanding servers and web requests\n\nNow that we know our business logic works, we can now start attaching our Flask routes to our core algorithms. But first let's understand conceptually how our web server will work.\n\nOur webserver is essentially a python program always running on a computer connected to the internet and it's constantly listening for requests. An example of a request is when a user tries to access our short link. When they access `https://short.com/x1GZrT` in their favorite browser, that browser is making a GET request (type of HTTP request) to our server that's hosted on `https://short.com` through the `/x1GZrT` route. Since we are writing the server, we're can return any type of data we want in our response.\n\nIn our app, we will return 2 different types of responses: First, we will return HTML code - essentially a website - to people who want to make their own short link. Second, we will return a URL Redirection response to people who are accessing short links.\n\n## Writing the Flask code\n\n### Creating a web interface\n\nI'm going to skip over the details of how to write a website for now (I have other tutorials on web dev). All you need to know is what the `index.html` code does. After the users type their long link into the textbox and submits it, their browser will send a POST request to our server at the `/create` endpoint through a form object. The way Flask serves websites is through a templating engine called Jinja and their [tutorial](https://pythonbasics.org/flask-tutorial-templates/) on how to utilize templating is actually pretty simple so I would check that out as well. Once again, the purpose of this write up isn't to learn web development but to see how one can implement a service in Python.\n\nTo serve websites in Flask, we're going to use a function called `render_template` that takes in an HTML file and a list of variables. We'll embed variables later on but for now, we just want to return a simple website that has a text input and a shorten! button. By default, Flask will look for templates in the `/templates` folder in our filesystem. In addition to the HTML, we need to add some CSS styles so our website doesn't look THAT ugly. We'll put these in a `/static` folder and you can just copy and paste these until you're more familiar with front-end web development.\n\n```file\n└── url-shortener\n\t├── templates\n\t│\t└── index.html\n\t├── static\n\t│\t└── styles.css\n\t├── app.py\n\t└── business_logic.py\n\n\n```\n```html templates/index.html\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>URL Shortener</title>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"{{ url_for('static', filename='styles.css') }}\" />\n    </head>\n\n    <body>\n        <form action=\"{{ url_for('create') }}\" method=\"POST\">\n            <div class=\"input--container\">\n                <input \n                    type=\"text\" \n                    name=\"link\" \n                    autocomplete=\"off\" \n                    required \n                    placeholder=\"ex. https://ryqn.dev/\" \n                />\n                <button>Shorten!</button>\n            </div>\n        </form>\n    </body>\n</html>\n```\n```css static/styles.css\nhtml, body {\n    margin: 0;\n    height: 100%;\n}\n\nbody {\n    display: grid;\n    place-content: center;\n    background-color: #151515;\n    font-size: 1.2em;\n}\n\n.input--container {\n    box-sizing: border-box;\n    width: 80vw;\n    max-width: 850px;\n    display: grid;\n    grid-template-columns: 1fr auto;\n    column-gap: 20px;\n    background-color: white;\n    border-radius: 4px;\n    padding: 15px;\n}\n\n.content {\n    display: grid;\n    place-content: center start;\n}\n\n.input--container>input[type=\"text\"] {\n    font-size: 1.5em;\n    border: none;\n}\n\n.input--container>input[type=\"text\"]:focus {\n    outline: none;\n}\n\n.input--container>button, .input--container>a>button {\n    font-size: 1em;\n    padding: 15px 25px;\n}\n\n.input--container>button:hover, .input--container>a>button:hover {\n    cursor: pointer;\n}\n\n```\n\nIn our Flask code, instead of returning the string \"Hello World!\" as we had before, we return a pretty website!\n\n```python app.py \nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n\treturn render_template(\"index.html\")\n\n```\n\nI mentioned earlier that when someone submits their long link into our website, their browser will make a POST request to the `/create` endpoint. This request will contain form data in this format `{ link: \"user_link_input_here\" }`. Thus, we can setup a route in our Flask server to handle this request like so:\n\n```python app.py\nfrom flask import Flask, render_template\nfrom business_logic import create_short_link, get_long_link\n# ...\n\n@app.route('/create', methods=['POST'])\ndef create():\n    server_url = request.host_url\n    long_link = request.form['link']\n    short_link = create_short_link(server_url, long_link)\n    return render_template(\"result.html\", short_link=short_link)\n\n```\nLet's go through this line by line.\n\nOn line 7: we define the `/create` route and specify it'll handle POST requests \\\nOn line 9: we get the current url of the server. (right now it should be http://localhost:5000) \\\nOn line 10: we are getting the user input value from the form data. \\\nOn line 11: we invoke the function we wrote earlier in `business_logic.py` \\\nOn line 12: we return an HTML file again, except this time we pass in the generated alias into the template to be displayed\n\nSince we're returning a different webpage, let's create `result.html` and define it like so:\n```file\n└── url-shortener\n\t├── templates\n\t│\t├── result.html\n\t│\t└── index.html\n\t├── static\n\t│\t└── styles.css\n\t├── app.py\n\t└── business_logic.py\n\n\n```\n```html templates/result.html\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>URL Shortener</title>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"{{ url_for('static', filename='styles.css') }}\" />\n    </head>\n\n    <body>\n        <div class=\"input--container\">\n            <div class=\"content\">\n                Success! You can now access your site from\n                <a href=\"{{ short_link }}\" target=\"_blank\" rel=\"noopener noreferrer\">\n                    {{ short_link }}\n                </a>\n            </div>\n\n            <a href=\"../\">\n                <button>\n                    Create another\n                </button>\n            </a>\n        </div>\n    </body>\n</html>\n\n```\n\n### Redirecting\nNow that we've handled how a user will generate a short link, let's go ahead and implement the redirection process.\n\n```python app.py\nfrom flask import Flask, render_template, request, redirect\n# ...\n\n@app.route('/<alias>', methods=['GET'])\ndef find_and_redirect(alias):\n     return redirect(get_long_link(alias), code=301)\n\n```\n\nOk. What does this all do?\n\nOn line 4: We setup something called a \"wildcard\" route. It takes the text that would go there and stores it in a variable called `alias`.\n\nI think seeing examples will help demonstrate how these wildcard routes work:\n\n|   |`@app.route('/<alias>')`|`@app.route('/<alias>/there')`|\n|---|---|---|\n| will match: | / **hey** |/ **hey** / there|\n|                 | / **this-super-long-text** | / **boop** / there |\n| will **NOT** match: | / hey / there | / hey  |\n\nOn line 6: Instead of returning HTML like we've done before, we will return a redirect response with a HTTP code 301. You can read the documentation for this function [here](https://flask.palletsprojects.com/en/2.0.x/api/#flask.redirect)\n\n## Final result\nOur final result should look like this:\n```file\n└── url-shortener\n\t├── templates\n\t│\t├── result.html\n\t│\t└── index.html\n\t├── static\n\t│\t└── styles.css\n\t├── app.py\n\t└── business_logic.py\n\n\n```\n\n```html templates/result.html\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>URL Shortener</title>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"{{ url_for('static', filename='styles.css') }}\" />\n    </head>\n\n    <body>\n        <div class=\"input--container\">\n            <div class=\"content\">\n                Success! You can now access your site from\n                <a href=\"{{ short_link }}\" target=\"_blank\" rel=\"noopener noreferrer\">\n                    {{ short_link }}\n                </a>\n            </div>\n\n            <a href=\"../\">\n                <button>\n                    Create another\n                </button>\n            </a>\n        </div>\n    </body>\n</html>\n\n```\n\n```html templates/index.html\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>URL Shortener</title>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"{{ url_for('static', filename='styles.css') }}\" />\n    </head>\n\n    <body>\n        <form action=\"{{ url_for('create') }}\" method=\"POST\">\n            <div class=\"input--container\">\n                <input \n                    type=\"text\" \n                    name=\"link\" \n                    autocomplete=\"off\" \n                    required \n                    placeholder=\"ex. https://ryqn.dev/\" \n                />\n                <button>Shorten!</button>\n            </div>\n        </form>\n    </body>\n</html>\n\n```\n\n```css static/styles.css\nhtml, body {\n    margin: 0;\n    height: 100%;\n}\n\nbody {\n    display: grid;\n    place-content: center;\n    background-color: #151515;\n    font-size: 1.2em;\n}\n\n.input--container {\n    box-sizing: border-box;\n    width: 80vw;\n    max-width: 850px;\n    display: grid;\n    grid-template-columns: 1fr auto;\n    column-gap: 20px;\n    background-color: white;\n    border-radius: 4px;\n    padding: 15px;\n}\n\n.content {\n    display: grid;\n    place-content: center start;\n}\n\n.input--container>input[type=\"text\"] {\n    font-size: 1.5em;\n    border: none;\n}\n\n.input--container>input[type=\"text\"]:focus {\n    outline: none;\n}\n\n.input--container>button, .input--container>a>button {\n    font-size: 1em;\n    padding: 15px 25px;\n}\n\n.input--container>button:hover, .input--container>a>button:hover {\n    cursor: pointer;\n}\n\n```\n\n```python app.py\nfrom flask import Flask, render_template, request, redirect\nfrom business_logic import create_short_link, get_long_link\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n\treturn render_template(\"index.html\")\n\n@app.route('/create', methods=['POST'])\ndef create():\n    server_url = request.host_url\n    long_link = request.form['link']\n    short_link = create_short_link(server_url, long_link)\n    return render_template(\"result.html\", short_link=short_link)\n\n@app.route('/<string:alias>', methods=['GET'])\ndef find_and_redirect(alias):\n    return redirect(get_long_link(alias), code=301)\n\n```\n\n```python business_logic.py\nimport random\n\nlink_mappings = {}\n\ndef create_short_link(server_url, long_link):\n    LENGTH_OF_ALIAS_ID = 6\n    unused_hash = generate_random_string(LENGTH_OF_ALIAS_ID)\n    link_mappings[unused_hash] = long_link\n    return server_url + unused_hash\n\ndef generate_random_string(length_of_string):\n    ALPHANUMERIC_CHARACTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n\n    while True: \n        valid_random_alphanumeric = ''.join(random.choice(\n            ALPHANUMERIC_CHARACTERS) for _ in range(length_of_string))\n\n        if valid_random_alphanumeric not in link_mappings:\n            return valid_random_alphanumeric\n\ndef get_long_link(short_link_id):\n    return link_mappings.get(short_link_id)\n\n```"}},"staticQueryHashes":[],"slicesMap":{}}